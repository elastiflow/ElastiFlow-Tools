#!/bin/bash

# Version: 1.0

elastiflow_flowcoll_version="7.0.2"
elastiflow_snmpcoll_version="7.0.2"
flowcoll_config_path="/etc/elastiflow/flowcoll.yml"
snmpcoll_config_path="/etc/elastiflow/snmpcoll.yml"
########################################################

# Leave blank
osversion=""

# Colors for messages
BLUE='\033[0;36m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

print_message() {
  local message=$1
  local color=$2
  echo -e "${color}${message}${NC}"
}

display_ascii_art() {
  echo -e "${BLUE}@@@@@@@@@@@@@@ @@@@@                                @@@@     @@@@  @@@@@@@@@@@@@@@ @@@@"
  echo "@@@@@@@@@@@@@  @@@@@                               @@@@@     @@@@  @@@@@@@@@@@@@@  @@@@"
  echo "@@@@           @@@@@     @@@@@@        @@@@@@    @@@@@@@@@@  @@@@  @@@@@           @@@@     @@@@@@@@   @@@@     @@@@     @@@@"
  echo "@@@@           @@@@@  @@@@@@@@@@@@  @@@@@@@@@@@@ @@@@@@@@@@        @@@@@           @@@@   @@@@@@@@@@@  @@@@@    @@@@@    @@@@"
  echo "@@@@@@@@@@     @@@@@ @@@@@@  @@@@@  @@@@@  @@@@@@@@@@@@@@@   @@@@  @@@@@@@@@@@     @@@@  @@@@@@@@@@@@@@ @@@@   @@@@@@   @@@@@"
  echo "@@@@@@@@@      @@@@@          @@@@@ @@@@@@@@       @@@@@     @@@@  @@@@@@@@@@      @@@@ @@@@@     @@@@@ @@@@   @@@@@@@  @@@@"
  echo "@@@@@@@@       @@@@@  @@@@@@@@@@@@@ @@@@@@@@@@@@   @@@@@     @@@@  @@@@@@@@        @@@@ @@@@@      @@@@  @@@@ @@@@ @@@ @@@@@"
  echo "@@@@           @@@@@ @@@@@@@@@@@@@@    @@@@@@@@@@  @@@@@     @@@@  @@@@@           @@@@ @@@@@     @@@@@  @@@@ @@@  @@@@@@@@"
  echo "@@@@@@@@@@@@@@ @@@@@ @@@@    @@@@@@@@@@@    @@@@@  @@@@@@    @@@@  @@@@@           @@@@ @@@@@@   @@@@@@   @@@@@@@   @@@@@@@"
  echo "@@@@@@@@@@@@@@ @@@@@ @@@@@@@@@@@@@@ @@@@@@@@@@@@    @@@@@@@  @@@@  @@@@@           @@@@  @@@@@@@@@@@@@    @@@@@@    @@@@@@"
  echo "@@@@@@@@@@@@@  @@@@@  @@@@@@@ @@@@@  @@@@@@@@@@      @@@@@@  @@@@  @@@@@           @@@@    @@@@@@@@@       @@@@@     @@@@@${NC}"
}

show_maxmind() {
  print_message "** Configure MaxMind Enrichment **" "$GREEN"
  print_message "Obtain Maxmind license key from: https://www.maxmind.com/en/geolite2/signup" "$GREEN"
  print_message "Log in to Maxmind.com, click 'My Account', and then 'Manage License Keys'" "$GREEN"
  print_message "**********************************" "$GREEN"
}

comment_and_replace_line() {
  local FILE=$1
  local FIND=$2
  local REPLACE=$3
  FIND_ESCAPED=$(echo "$FIND" | sed 's/[.[\*^$]/\\&/g')
  REPLACE_ESCAPED=$(echo "$REPLACE" | sed 's/[&/\]/\\&/g')

  if grep -Eq "^[#]*$FIND_ESCAPED" "$FILE"; then
    sed -i.bak "/^[#]*$FIND_ESCAPED/c\\$REPLACE" "$FILE"
    print_message "Replaced '$FIND' with '$REPLACE'." "$GREEN"
  else
    if grep -q "^#ElastiFlow PoC Configurator" "$FILE"; then
      sed -i.bak "/^#ElastiFlow PoC Configurator/a $REPLACE" "$FILE"
      print_message "Added '$REPLACE' under '#ElastiFlow PoC Configurator'." "$GREEN"
    else
      echo -e "\n#ElastiFlow PoC Configurator" | tee -a "$FILE" > /dev/null
      sed -i.bak "/^#ElastiFlow PoC Configurator/a $REPLACE" "$FILE"
      print_message "Added heading and '$REPLACE'." "$GREEN"
    fi
  fi
}

check_for_updates() {
  # Dynamically determine the path to the current script
  local current_script=$(realpath "$0")
  local new_script_url="https://raw.githubusercontent.com/elastiflow/ElastiFlow-Tools/main/elastiflow_installation_scripts/flowcoll_snmpcoll_installation_script"
  local tmp_script="/tmp/install"

  echo "Checking for updates..."
  echo "Current script path: $current_script"

  wget -q -O "$tmp_script" "$new_script_url"

  if [[ $? -ne 0 ]]; then
    print_message "Failed to check for updates." "$RED"
    return
  fi

  echo "Downloaded new script to $tmp_script."

  local new_version=$(grep -m 1 '^# Version: ' "$tmp_script" | awk '{print $3}')
  local current_version=$(grep -m 1 '^# Version: ' "$current_script" | awk '{print $3}')

  echo "Current version: $current_version"
  echo "Remote version: $new_version"

  if [[ -z "$current_version" ]]; then
    print_message "Failed to detect the current version." "$RED"
    return
  fi

  if [[ "$new_version" > "$current_version" ]]; then
    print_message "Remote version $new_version available." "$GREEN"
    
    while true; do
      echo -n "Do you want to update to the Remote version? (y/n) [y]: "
      for i in {10..1}; do
        echo -n "$i "
        sleep 1
      done
      echo
      
      read -t 1 -n 1 update_choice
      update_choice=${update_choice:-y}
      
      if [[ $update_choice == "y" || $update_choice == "n" ]]; then
        break
      else
        echo "Invalid input. Please enter 'y' or 'n'."
      fi
    done

    if [[ $update_choice == "y" ]]; then
      print_message "Updating to version $new_version..." "$GREEN"
      cp "$tmp_script" "$current_script"
      chmod +x "$current_script"
      print_message "Update successful. Restarting script..." "$GREEN"
      exec "$current_script"
    else
      print_message "Update skipped." "$RED"
    fi
  else
    print_message "No updates available." "$GREEN"
  fi

  echo "Cleaning up temporary script."
  rm -f "$tmp_script"
}

find_and_replace() {
  local FILE=$1
  shift
  local PAIRS=("$@")
  if [ ! -f "$FILE" ]; then
    print_message "File not found!" "$RED"
    exit 1
  fi
  for ((i = 0; i < ${#PAIRS[@]}; i+=2)); do
    comment_and_replace_line "$FILE" "${PAIRS[i]}" "${PAIRS[i+1]}"
  done
}

handle_error() {
  local error_msg="$1"
  local line_num="$2"
  echo "Error at line $line_num: $error_msg"
  read -p "Do you wish to continue? (y/n): " user_decision
  if [[ $user_decision != "y" ]]; then
    echo "Exiting..."
    exit 1
  fi
}

replace_text() {
  local file_path="$1"
  local old_text="$2"
  local new_text="$3"
  local line_num="$4"
  sed -i.bak "s|$old_text|$new_text|g" "$file_path" || handle_error "Failed to replace text in $file_path." "$line_num"
}

check_for_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root" 1>&2
    exit 1
  fi
}

check_compatibility() {
  . /etc/os-release
  ID_LOWER=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
  if [[ "$ID_LOWER" != "rhel" && "$ID_LOWER" != "centos" ]]; then
    echo "This script only supports Red Hat Enterprise Linux or CentOS" 1>&2
    exit 1
  fi
  osversion="rhel"
}

# Function to prompt for Elasticsearch connection information
prompt_elasticsearch_connection() {
  while true; do
    read -p "Enter Elasticsearch IP: " elasticsearch_ip
    read -p "Enter Elasticsearch Port (default 9200): " elasticsearch_port
    elasticsearch_port=${elasticsearch_port:-9200}
    read -p "Enter Elasticsearch Protocol (http/https, default http): " elasticsearch_protocol
    elasticsearch_protocol=${elasticsearch_protocol:-http}
    read
