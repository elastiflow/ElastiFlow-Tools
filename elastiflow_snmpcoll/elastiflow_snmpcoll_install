#!/bin/bash

# Version: 1.0

########################################################
# If you do not have an ElastiFlow Account ID and ElastiFlow Flow License Key, 
# please go here: https://elastiflow.com/get-started
# Paste these values on the corresponding line, between the quotes
########################################################

elastiflow_version="7.0.2"
kibana_dashboards_version="8.14.x"
kibana_dashboards_codex_ecs="codex"
flowcoll_config_path="/etc/elastiflow/flowcoll.yml"
########################################################

#leave blank
osversion=""
enable_elasticsearch_connection_check=0

# Colors for messages
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

print_message() {
  local message=$1
  local color=$2
  echo -e "${color}${message}${NC}"
}

comment_and_replace_line() {
  local FILE=$1
  local FIND=$2
  local REPLACE=$3
  FIND_ESCAPED=$(echo "$FIND" | sed 's/[.[\*^$]/\\&/g')
  REPLACE_ESCAPED=$(echo "$REPLACE" | sed 's/[&/\]/\\&/g')

  if grep -Eq "^[#]*$FIND_ESCAPED" "$FILE"; then
    sed -i.bak "/^[#]*$FIND_ESCAPED/c\\$REPLACE" "$FILE"
    print_message "Replaced '$FIND' with '$REPLACE'." "$GREEN"
  else
    if grep -q "^#ElastiFlow PoC Configurator" "$FILE"; then
      sed -i.bak "/^#ElastiFlow PoC Configurator/a $REPLACE" "$FILE"
      print_message "Added '$REPLACE' under '#ElastiFlow PoC Configurator'." "$GREEN"
    else
      echo -e "\n#ElastiFlow PoC Configurator" | tee -a "$FILE" > /dev/null
      sed -i.bak "/^#ElastiFlow PoC Configurator/a $REPLACE" "$FILE"
      print_message "Added heading and '$REPLACE'." "$GREEN"
    fi
  fi
}

check_for_updates() {
  # Dynamically determine the path to the current script
  local current_script=$(realpath "$0")
  local new_script_url="https://raw.githubusercontent.com/elastiflow/ElastiFlow-Tools/main/elastiflow_snmpcoll/elastiflow_snmpcoll_install"
  local tmp_script="/tmp/install"

  echo "Checking for updates..."
  echo "Current script path: $current_script"

  wget -q -O "$tmp_script" "$new_script_url"

  if [[ $? -ne 0 ]]; then
    print_message "Failed to check for updates." "$RED"
    return
  fi

  echo "Downloaded new script to $tmp_script."

  local new_version=$(grep -m 1 '^# Version: ' "$tmp_script" | awk '{print $3}')
  local current_version=$(grep -m 1 '^# Version: ' "$current_script" | awk '{print $3}')

  echo "Current version: $current_version"
  echo "Remote version: $new_version"

  if [[ -z "$current_version" ]]; then
    print_message "Failed to detect the current version." "$RED"
    return
  fi

  if [[ "$new_version" > "$current_version" ]]; then
    print_message "Remote version $new_version available." "$GREEN"
    
    while true; do
      echo -n "Do you want to update to the Remote version? (y/n) [y]: "
      for i in {10..1}; do
        echo -n "$i "
        sleep 1
      done
      echo
      
      read -t 1 -n 1 update_choice
      update_choice=${update_choice:-y}
      
      if [[ $update_choice == "y" || $update_choice == "n" ]]; then
        break
      else
        echo "Invalid input. Please enter 'y' or 'n'."
      fi
    done

    if [[ $update_choice == "y" ]]; then
      print_message "Updating to version $new_version..." "$GREEN"
      cp "$tmp_script" "$current_script"
      chmod +x "$current_script"
      print_message "Update successful. Restarting script..." "$GREEN"
      exec "$current_script"
    else
      print_message "Update skipped." "$RED"
    fi
  else
    print_message "No updates available." "$GREEN"
  fi

  echo "Cleaning up temporary script."
  rm -f "$tmp_script"
}


find_and_replace() {
  local FILE=$1
  shift
  local PAIRS=("$@")
  if [ ! -f "$FILE" ]; then
    print_message "File not found!" "$RED"
    exit 1
  fi
  for ((i = 0; i < ${#PAIRS[@]}; i+=2)); do
    comment_and_replace_line "$FILE" "${PAIRS[i]}" "${PAIRS[i+1]}"
  done
}

handle_error() {
  local error_msg="$1"
  local line_num="$2"
  echo "Error at line $line_num: $error_msg"
  read -p "Do you wish to continue? (y/n): " user_decision
  if [[ $user_decision != "y" ]]; then
    echo "Exiting..."
    exit 1
  fi
}

replace_text() {
  local file_path="$1"
  local old_text="$2"
  local new_text="$3"
  local line_num="$4"
  sed -i.bak "s|$old_text|$new_text|g" "$file_path" || handle_error "Failed to replace text in $file_path." "$line_num"
}

check_for_root() {
  if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root" 1>&2
    exit 1
  fi
}

check_compatibility() {
  . /etc/os-release
  ID_LOWER=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
  if [[ "$ID_LOWER" != "ubuntu" ]]; then
    echo "This script only supports Ubuntu" 1>&2
    exit 1
  fi
  osversion="ubuntu"
}

print_startup_message() {
  printf "*********\n"
  printf "*********\n"
  printf "*********Setting up ElastiFlow environment...*********\n"
  printf "*********\n"
  printf "*********\n"
}

install_prerequisites() {
  printf "\n\n\n*********Installing prerequisites...\n\n"

  echo "Updating package list..."
  apt-get -qq update > /dev/null 2>&1

  # List of packages to be installed
  packages=(jq net-tools git bc gpg curl wget unzip apt-transport-https libpcap-dev)

  # Loop through the list and install each package
  for package in "${packages[@]}"; do
    echo "Installing $package..."
    apt-get -qq install -y "$package" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      echo "$package installed successfully."
    else
      echo "Failed to install $package."
    fi
  done
}

# Function to check the service health
check_service_health() {
  print_message "Checking if flowcoll.service stays running for at least 10 seconds..." "$GREEN"
  sleep 10
  if ! systemctl is-active --quiet flowcoll.service; then
    print_message "flowcoll.service did not stay started." "$RED"
    if journalctl -u flowcoll.service | grep -q "license error"; then
      print_message "License error found in logs. Exiting to main menu." "$RED"
    else
      print_message "Rerunning the configuration routine." "$GREEN"
    fi
    return 1
  else
    print_message "flowcoll.service restarted successfully and stayed running for at least 10 seconds." "$GREEN"
    return 0
  fi
}


# Function to verify Elasticsearch connection
verify_elasticsearch() {
  local protocol=$1
  local ip=$2
  local port=$3
  local password=$4
  local response=$(curl -s -o /dev/null -w "%{http_code}" -u "elastic:${password}" "${protocol}://${ip}:${port}")
  if [ "$response" -eq 200 ]; then
    return 0
  else
    return 1
  fi
}


install_snmp_collector() {
  # Prompt the user for the ElastiFlow Account ID
  while true; do
    read -p "Enter your ElastiFlow Account ID (or 'q' to quit): " elastiflow_account_id
    if [[ $elastiflow_account_id == "q" ]]; then
      return
    elif [[ -z $elastiflow_account_id ]]; then
      print_message "ElastiFlow Account ID cannot be empty. Please enter a valid ID." "$RED"
    else
      break
    fi
  done

  # Prompt the user for the SNMP flow key
  while true; do
    read -p "Enter your ElastiFlow SNMP License Key (or 'q' to quit): " elastiflow_snmp_license_key
    if [[ $elastiflow_snmp_license_key == "q" ]]; then
      return
    elif [[ -z $elastiflow_snmp_license_key ]]; then
      print_message "ElastiFlow SNMP License Key cannot be empty. Please enter a valid key." "$RED"
    else
      break
    fi
  done


  # Extract the Elasticsearch password from the configuration file
  elastic_password=$(grep "^EF_OUTPUT_ELASTICSEARCH_PASSWORD: '" "$elastiflow_flow_config_path" | awk -F"'" '{print $2}')


  if [ -z "$elastic_password" ]; then
    print_message "Failed to extract Elasticsearch password from $elastiflow_flow_config_path" "$RED"
    return
  fi

  elastiflow_snmp_config_strings=(
    "EF_LICENSE_ACCEPTED" "EF_LICENSE_ACCEPTED: \"true\""
    "EF_ACCOUNT_ID" "EF_ACCOUNT_ID: \"${elastiflow_account_id}\""
    "EF_SNMP_LICENSE_KEY" "EF_SNMP_LICENSE_KEY: \"${elastiflow_snmp_license_key}\""
    "EF_OUTPUT_ELASTICSEARCH_ENABLE" "EF_OUTPUT_ELASTICSEARCH_ENABLE: \"true\""
    "EF_OUTPUT_ELASTICSEARCH_ADDRESSES" "EF_OUTPUT_ELASTICSEARCH_ADDRESSES: \"127.0.0.1:9200\""
    "EF_OUTPUT_ELASTICSEARCH_PASSWORD" "EF_OUTPUT_ELASTICSEARCH_PASSWORD: '$elastic_password'"
    "EF_OUTPUT_ELASTICSEARCH_TLS_ENABLE" "EF_OUTPUT_ELASTICSEARCH_TLS_ENABLE: \"true\""
    "EF_OUTPUT_ELASTICSEARCH_TLS_SKIP_VERIFICATION" "EF_OUTPUT_ELASTICSEARCH_TLS_SKIP_VERIFICATION: \"true\""
  )


  print_message "Installing ElastiFlow Unified SNMP Collector..." "$GREEN"
  
  # Update package list and install prerequisites
  apt-get update -qq
  apt-get install -qq -y snmp snmpd snmp-mibs-downloader curl apt-transport-https gnupg
  
  # Download the ElastiFlow SNMP collector package
  wget -q -O elastiflow-snmpcollector.deb "https://elastiflow-releases.s3.us-east-2.amazonaws.com/snmp-collector/snmp-collector_${elastiflow_snmp_collector_version}_linux_amd64.deb"

  # Install the package
  dpkg -i elastiflow-snmpcollector.deb

  find_and_replace "$elastiflow_snmp_config_path" "${elastiflow_snmp_config_strings[@]}"

  # Enable and start the SNMP collector service
  systemctl enable snmpcoll.service
  systemctl start snmpcoll.service

  # Install SNMP dashboards
  printf "\n\n\n*********Downloading and installing ElastiFlow SNMP dashboards\n\n"

  # Remove the existing directory if it exists
  if [ -d "/etc/elastiflow_for_elasticsearch" ]; then
    rm -rf /etc/elastiflow_for_elasticsearch
  fi
  
  # Clone the repository
  git clone https://github.com/elastiflow/elastiflow_for_elasticsearch.git /etc/elastiflow_for_elasticsearch/

  # Path to the downloaded JSON file
  json_file="/etc/elastiflow_for_elasticsearch/kibana/snmp/kibana-$kibana_dashboards_version-snmp-$kibana_dashboards_codex_ecs.ndjson"
  
  # Perform find and replace in the JSON file
  sed -i 's/elastiflow-\*-codex-\*/elastiflow-telemetry_\*-codex-\*/g' "$json_file"

  response=$(curl --silent --show-error --fail --connect-timeout 10 -X POST -u "$elastic_username:$elastic_password" \
    "localhost:5601/api/saved_objects/_import?overwrite=true" \
    -H "kbn-xsrf: true" \
    --form file=@"$json_file" \
    -H 'kbn-xsrf: true')

  dashboards_success=$(echo "$response" | jq -r '.success')

  if [ "$dashboards_success" == "true" ]; then
    print_message "SNMP dashboards installed successfully." "$GREEN"
  else
    print_message "SNMP dashboards not installed successfully." "$RED"
    echo "Debug: API response:"
    echo "$response"
  fi

  # Check the status of the service
  if systemctl is-active --quiet snmpcoll.service; then
    print_message "ElastiFlow Unified SNMP Collector installed and running." "$GREEN"
  else
    print_message "Failed to start ElastiFlow Unified SNMP Collector." "$RED"
  fi
}



# Main script
check_for_updates
print_startup_message
check_for_root
check_compatibility
install_prerequisites
install_elastiflow
configure_elastiflow
